{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is AAct?","text":"<p>AAct is designed for communicating sensors, neural networks, agents, users, and environments.</p> Can you expand on that?  AAct is a Python library for building asynchronous, actor-based, concurrent systems. Specifically, it is designed to be used in the context of building systems with components that communicate with each other but don't block each other."},{"location":"#how-does-aact-work","title":"How does AAct work?","text":"<p>AAct is built around the concept of nodes and dataflow, where nodes are self-contained units which receive messages from input channels, process the messages, and send messages to output channels. Nodes are connected to each other to form a dataflow graph, where messages flow from one node to another. Each node runs in its own event loop, and the nodes communicate with each other using Redis Pub/Sub.</p>"},{"location":"install/","title":"Quickstart","text":""},{"location":"install/#installation","title":"Installation","text":"<p>System requirement:</p> <ol> <li>Python 3.10 or higher</li> <li>Redis server</li> </ol> Redis installation  The easiest way to install Redis is to use Docker:  <pre><code>docker run -d --name redis-stack -p 6379:6379 -p 8001:8001 redis/redis-stack:latest\n</code></pre>  According to your system, you can also install Redis from the official website: https://redis.io/download  Note: we will only require a standard Redis server (without RedisJSON / RedisSearch) in this library.   <pre><code>pip install aact\n</code></pre>  from source  <pre><code>git clone https://github.com/ProKil/aact.git\ncd aact\npip install .\n</code></pre>   For power users, please use `uv` for package management."},{"location":"install/#quick-start-example","title":"Quick Start Example","text":"<p>Assuming your Redis is hosted on <code>localhost:6379</code> using docker. You can create a <code>dataflow.toml</code> file:</p> <pre><code>redis_url = \"redis://localhost:6379/0\" # required\n\n[[nodes]]\nnode_name = \"print\"\nnode_class = \"print\"\n\n[nodes.node_args.print_channel_types]\n\"tick/secs/1\" = \"tick\"\n\n[[nodes]]\nnode_name = \"tick\"\nnode_class = \"tick\"\n</code></pre> <p>To run the dataflow:</p> <pre><code>aact run-dataflow dataflow.toml\n</code></pre> <p>This will start the <code>tick</code> node and the <code>print</code> node. The <code>tick</code> node sends a message every second to the <code>print</code> node, which prints the message to the console.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#usage","title":"Usage","text":""},{"location":"usage/#cli","title":"CLI","text":"<p>You can start from CLI and progress to more advanced usages.</p> <ol> <li><code>aact --help</code> to see all commands</li> <li><code>aact run-dataflow &lt;dataflow_name.toml&gt;</code>  to run a dataflow. Check Dataflow.toml syntax</li> <li><code>aact run-node</code> to run one node in a dataflow.</li> <li><code>aact draw-dataflow &lt;dataflow_name_1.toml&gt; &lt;dataflow_name_2.toml&gt; --svg-path &lt;output.svg&gt;</code> to draw dataflow.</li> </ol>"},{"location":"usage/#customized-node","title":"Customized Node","text":"<p>Here is the minimal knowledge you would need to implement a customized node.</p> <pre><code>from aact import Node, NodeFactory, Message\n\n@NodeFactory.register(\"node_name\")\nclass YourNode(Node[your_input_type, your_output_type]):\n\n    # event_handler is the only function your **have** to implement\n    def event_handler(self, input_channel: str, input_message: Message[your_input_type]) -&gt; AsyncIterator[str, Message[your_output_type]]:\n        match input_channel:\n            case input_channel_1:\n                &lt;do_your_stuff&gt;\n                yield output_channel_1, Message[your_output_type](data=your_output_message)\n            case input_channel_2:\n                ...\n\n   # implement other functions: __init__, _wait_for_input, event_loop, __aenter__, __aexit__\n\n# To run a node without CLI\nasync with NodeFactory.make(\"node_name\", arg_1, arg_2) as node:\n    await node.event_loop()\n</code></pre>"},{"location":"usage/#concepts","title":"Concepts","text":"<p>There are three important concepts to understand aact.</p> <pre><code>graph TD\n    n1[Node 1] --&gt;|channel_1| n2[Node 2]\n</code></pre>"},{"location":"usage/#nodes","title":"Nodes","text":"<p>Nodes (<code>aact.Nodes</code>) are designed to run in parallel asynchronously. This design is especially useful for deploying the nodes onto different machines. A node should inherit <code>aact.Node</code> class, which extends <code>pydantic.BaseModel</code>.</p>"},{"location":"usage/#channels","title":"Channels","text":"<p>Channel is an inherited concept from Redis Pub/Sub. You can think of it as a radio channel. Multiple publishers (nodes) can publish messages to the same channel, and multiple subscribers (nodes) can subscribe to the same channel.</p>"},{"location":"usage/#messages","title":"Messages","text":"<p>Messages are the data sent through the channels. Each message type is a class in the format of <code>Message[T]</code> , where <code>T</code> is a subclass or a union of subclasses of <code>DataModel</code>.</p>"},{"location":"usage/#customized-message-type","title":"Customized Message Type","text":"<p>If you want to create a new message type, you can create a new class that inherits from <code>DataModel</code>.</p> <pre><code>@DataModelFactory.register(\"new_type\")\nclass NewType(DataModel):\n    new_type_data: ... = ...\n\n\n# For example\n@DataModelFactory.register(\"integer\")\nclass Integer(DataModel):\n    integer_data: int = Field(default=0)\n</code></pre>"},{"location":"usage/#dataflowtoml-syntax","title":"Dataflow.toml syntax","text":"<pre><code>redis_url = \"redis://...\" # required\nextra_modules = [\"package1.module1\", \"package2.module2\"] # optional\n\n[[nodes]]\nnode_name = \"node_name_1\" # A unique name in the dataflow\nnode_class = \"node_class_1\" # node_class should match the class name passed into NodeFactory.register\n\n[node.node_args]\nnode_arg_1 = \"value_1\"\n\n[[nodes]]\nnode_name = \"node_name_2\"\nnode_class = \"node_class_2\"\n\n# ...\n</code></pre>"},{"location":"why/","title":"Why use AAct","text":""},{"location":"why/#why-should-i-use-aact","title":"Why should I use AAct?","text":"<ol> <li>Non-blocking: the nodes are relatively independent of each other, so if you are waiting for users' input,     you can still process sensor data in the background.</li> <li>Scalable: you can a large number of nodes on one machine or distribute them across multiple machines.</li> <li>Hackable: you can easily design your own nodes and connect them to the existing nodes.</li> <li>Zero-code configuration: the <code>dataflow.toml</code> allows you to design the dataflow graph without writing any     Python code.</li> </ol>"},{"location":"api/messages/","title":"Messages","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>               Bases: <code>BaseModel</code></p>"},{"location":"api/messages/#aact.Message--messages","title":"Messages","text":"<p>Message class is the base class for all of the messages passing through the channels. It is a pydantic BaseModel with a single field <code>data</code> containing the actual data. The <code>data</code> field is a subclass of <code>aact.messages.DataModel</code>.</p>"},{"location":"api/messages/#aact.Message--usage","title":"Usage","text":"<p>To create a message type with DataModel <code>T</code>, you can use <code>Message[T]</code>. To initialize a message, you can use <code>Message[T](data=your_data_model_instance)</code>.</p>  Why have an additional wrapper over DataModel?   The reason for having a separate class for messages is to leverage the [pydantic's tagged union feature](https://docs.pydantic.dev/latest/concepts/performance/#use-tagged-union-not-union). This allows us to differentiate between different message types at runtime.  For example, the following code snippet shows how to decide the message type at runtime:   <pre><code>from aact import Message, DataModel\nfrom aact.messages import Image, Tick\n\ntick = 123\ntick_message = Message[Tick](data=Tick(tick=tick))\ntick_message_json = tick_message.model_dump_json()\n\npossible_image_or_tick_message = Message[Tick | Image].model_validate_json(\n    tick_message_json\n)\nassert isinstance(possible_image_or_tick_message.data, Tick)\n</code></pre>"},{"location":"api/messages/#aact.Message.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: T = Field(discriminator='data_type')\n</code></pre> <p>@private</p>"},{"location":"api/messages/#aact.messages.DataModel--datamodel","title":"DataModel","text":"<p>A datamodel in <code>aact</code> is a pydantic BaseModel with an additional field <code>data_type</code> to differentiate between different message types.</p> <p>Here are the built-in data models:</p> <ul> <li><code>aact.message.Tick</code>: A data model with a single field <code>tick</code> of type <code>int</code>. This is useful for sending clock ticks.</li> <li><code>aact.messages.Float</code>: A data model with a single field <code>value</code> of type <code>float</code>. This is useful for sending floating-point numbers.</li> <li><code>aact.messages.Image</code>: A data model with a single field <code>image</code> of type <code>bytes</code>. This is useful for sending images.</li> <li><code>aact.messages.Text</code>: A data model with a single field <code>text</code> of type <code>str</code>. This is useful for sending text messages.</li> <li><code>aact.messages.Audio</code>: A data model with a single field <code>audio</code> of type <code>bytes</code>. This is useful for sending audio files.</li> <li><code>aact.messages.Zero</code>: A dummy data model with no fields. This is useful when the nodes do not receive or send any data.</li> </ul>"},{"location":"api/messages/#aact.messages.DataModel--customize-datamodels","title":"Customize DataModels","text":"<p>For custimizing your own data models, here is an example:</p> <pre><code>\nfrom aact.messages import DataModel, DataModelFactory\n\n\n@DataModelFactory.register(\"my_data_model\")\nclass MyDataModel(DataModel):\n    my_field: str\n</code></pre> <p>You can see that you don't need to define the <code>data_type</code> field in your custom data models. The <code>DataModelFactory</code> will take care of it for you.</p>"},{"location":"api/messages/#aact.messages.DataModel.data_type","title":"data_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_type: Literal[''] = Field('')\n</code></pre> <p>@private</p>"},{"location":"api/nodes/","title":"Nodes","text":"<p>AAct nodes are simply classes which inherit from <code>Node</code> and implements different ways of handling and sending messages.</p>"},{"location":"api/nodes/#aact.Node","title":"aact.Node","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[InputType, OutputType]</code></p> <p>Node is the base class for all nodes in the aact framework. It is a generic class that takes two type parameters: <code>InputType</code> and <code>OutputType</code>. The InputType and OutputType is used not only for static type checking but also for runtime message type validation, so it is important that you pass the correct types.</p> <p>Each of <code>InputType</code> and <code>OutputType</code> can be either: 1. a subclass of <code>aact.messages.DataModel</code>, or 2. a union of multiple <code>aact.DataModel</code> subclasses, or 3. <code>aact.DataModel</code> itself to allow any type of message (not recommended).[^1]</p> <p>Any subclass of <code>aact.Node</code> must implement the <code>event_handler</code> method, which is the main computation logic of the node. The <code>event_handler</code> method takes two arguments: <code>input_channel</code> and <code>input_message</code>, and returns an async iterator of tuples of output channel and output message.</p> <p>For example, the following code snippet shows a simple node that takes a <code>aact.messages.Text</code> message from the <code>a</code> channel and echo it to the <code>b</code> channel.</p> <pre><code>from aact import Node, Message\nfrom aact.messages import Text\n\nfrom typing import AsyncIterator\n\nclass EchoNode(Node[Text, Text]):\n    def event_handler(self, input_channel: str, input_message: Message[Text]) -&gt; AsyncIterator[str, Message[Text]]:\n        yield \"b\", Message[Text](data=input_message.data)\n</code></pre>"},{"location":"api/nodes/#aact.Node--built-in-nodes","title":"Built-in Nodes","text":"<p>aact provides several built-in nodes that you can use out of the box. Here are some of the built-in nodes:</p> <ul> <li><code>aact.nodes.listener.ListenerNode</code>: A node that listens to the audio input from the microphone.</li> <li><code>aact.nodes.speaker.SpeakerNode</code>: A node that plays the audio output to the speaker.</li> <li><code>aact.nodes.record.RecordNode</code>: A node that records the messages to a file.</li> <li><code>aact.nodes.print.PrintNode</code>: A node that prints the messages to the console.</li> <li><code>aact.nodes.tick.TickNode</code>: A node that sends a tick message at a fixed interval.</li> <li><code>aact.nodes.random.RandomNode</code>: A node that sends a random number message.</li> <li><code>aact.nodes.transcriber.TranscriberNode</code>: A node that transcribes the audio messages to text.</li> <li><code>aact.nodes.tts.TTSNode</code>: A node that converts the text messages to audio.</li> </ul>"},{"location":"api/nodes/#aact.Node--common-usage","title":"Common usage","text":"<p>The usage of nodes is in the quick start guide.</p>"},{"location":"api/nodes/#aact.Node--advanced-usage","title":"Advanced usage","text":""},{"location":"api/nodes/#aact.Node--send-messages-on-your-own","title":"Send messages on your own","text":"<p>The default behavior of sending messages in the base Node class is handled in the <code>event_loop</code> method. If you want to send messages on your own, you can directly use the Redis instance <code>r</code> to publish messages to the output channels.</p> <pre><code>\nclass YourNode(Node[InputType, OutputType]):\n\n    async def func_where_you_send_messages(self):\n        await self.r.publish(your_output_channel, Message[OutputType](data=your_output_message).model_dump_json())\n\n</code></pre>"},{"location":"api/nodes/#aact.Node--customize-set-up-and-tear-down","title":"Customize set up and tear down","text":"<p>You can customize the set up and tear down of the node by overriding the <code>__aenter__</code> and <code>__aexit__</code> methods. For example, you can open a file in the <code>__aenter__</code> method and close it in the <code>__aexit__</code> method.</p> <pre><code>\nclass YourNode(Node[InputType, OutputType]):\n\n    async def __aenter__(self) -&gt; Self:\n        self.file = open(\"your_file.txt\", \"w\")\n        return await super().__aenter__()\n\n    async def __aexit__(self, exc_type: Any, exc_value: Any, traceback: Any) -&gt; None:\n        self.file.close()\n        return await super().__aexit__(exc_type, exc_value, traceback)\n</code></pre> <p>This will ensure the file is closed properly even if an exception is raised.</p>"},{"location":"api/nodes/#aact.Node--background-tasks","title":"Background tasks","text":"<p>You can run background tasks in the node by creating a task in the <code>__aenter__</code> method and cancelling it in the <code>__aexit__</code> method.</p> <pre><code>\nclass YourNode(Node[InputType, OutputType]):\n\n    async def __aenter__(self) -&gt; Self:\n\n        self.task = asyncio.create_task(self.background_task())\n        return await super().__aenter__()\n\n    async def __aexit__(self, exc_type: Any, exc_value: Any, traceback: Any) -&gt; None:\n        self.task.cancel()\n\n        try:\n            await self.task\n        except asyncio.CancelledError:\n            pass\n</code></pre> <p>[^1]: Only if you know what you are doing. For example, in the <code>aact.nodes.record.RecordNode</code>, the <code>InputType</code> is <code>aact.messages.DataModel</code> because it can accept any type of message. But in most cases, you should specify the <code>InputType</code> and <code>OutputType</code> to be a specific subclass of <code>aact.messages.DataModel</code>.</p> Source code in <code>src/aact/nodes/base.py</code> <pre><code>class Node(BaseModel, Generic[InputType, OutputType]):\n    \"\"\"\n    Node is the base class for all nodes in the aact framework. It is a generic class that takes two type parameters:\n    `InputType` and `OutputType`. The InputType and OutputType is used not only for static type checking but also for\n    runtime message type validation, so it is important that you pass the correct types.\n\n    Each of `InputType` and `OutputType` can be either:\n    1. a subclass of `aact.messages.DataModel`, or\n    2. a union of multiple `aact.DataModel` subclasses, or\n    3. `aact.DataModel` itself to allow any type of message (not recommended).[^1]\n\n    Any subclass of `aact.Node` must implement the `event_handler` method, which is the main computation logic of the\n    node. The `event_handler` method takes two arguments: `input_channel` and `input_message`, and returns an async\n    iterator of tuples of output channel and output message.\n\n    For example, the following code snippet shows a simple node that takes a `aact.messages.Text` message from the `a`\n    channel and echo it to the `b` channel.\n\n    ```python\n    from aact import Node, Message\n    from aact.messages import Text\n\n    from typing import AsyncIterator\n\n    class EchoNode(Node[Text, Text]):\n        def event_handler(self, input_channel: str, input_message: Message[Text]) -&gt; AsyncIterator[str, Message[Text]]:\n            yield \"b\", Message[Text](data=input_message.data)\n    ```\n\n    ## Built-in Nodes\n\n    aact provides several built-in nodes that you can use out of the box. Here are some of the built-in nodes:\n\n    - `aact.nodes.listener.ListenerNode`: A node that listens to the audio input from the microphone.\n    - `aact.nodes.speaker.SpeakerNode`: A node that plays the audio output to the speaker.\n    - `aact.nodes.record.RecordNode`: A node that records the messages to a file.\n    - `aact.nodes.print.PrintNode`: A node that prints the messages to the console.\n    - `aact.nodes.tick.TickNode`: A node that sends a tick message at a fixed interval.\n    - `aact.nodes.random.RandomNode`: A node that sends a random number message.\n    - `aact.nodes.transcriber.TranscriberNode`: A node that transcribes the audio messages to text.\n    - `aact.nodes.tts.TTSNode`: A node that converts the text messages to audio.\n\n    ## Common usage\n\n    The usage of nodes is in the [quick start guide](aact.html/#usage).\n\n    ## Advanced usage\n\n    ### Send messages on your own\n\n    The default behavior of sending messages in the base Node class is handled in the `event_loop` method. If you want to\n    send messages on your own, you can directly use the Redis instance `r` to publish messages to the output channels.\n\n    ```python\n\n    class YourNode(Node[InputType, OutputType]):\n\n        async def func_where_you_send_messages(self):\n            await self.r.publish(your_output_channel, Message[OutputType](data=your_output_message).model_dump_json())\n\n    ```\n\n    ### Customize set up and tear down\n\n    You can customize the set up and tear down of the node by overriding the `__aenter__` and `__aexit__` methods. For\n    example, you can open a file in the `__aenter__` method and close it in the `__aexit__` method.\n\n    ```python\n\n    class YourNode(Node[InputType, OutputType]):\n\n        async def __aenter__(self) -&gt; Self:\n            self.file = open(\"your_file.txt\", \"w\")\n            return await super().__aenter__()\n\n        async def __aexit__(self, exc_type: Any, exc_value: Any, traceback: Any) -&gt; None:\n            self.file.close()\n            return await super().__aexit__(exc_type, exc_value, traceback)\n    ```\n\n    This will ensure the file is closed properly even if an exception is raised.\n\n    ### Background tasks\n\n    You can run background tasks in the node by creating a task in the `__aenter__` method and cancelling it in the\n    `__aexit__` method.\n\n    ```python\n\n    class YourNode(Node[InputType, OutputType]):\n\n        async def __aenter__(self) -&gt; Self:\n\n            self.task = asyncio.create_task(self.background_task())\n            return await super().__aenter__()\n\n        async def __aexit__(self, exc_type: Any, exc_value: Any, traceback: Any) -&gt; None:\n            self.task.cancel()\n\n            try:\n                await self.task\n            except asyncio.CancelledError:\n                pass\n    ```\n\n    [^1]: Only if you know what you are doing. For example, in the `aact.nodes.record.RecordNode`, the `InputType` is\n    `aact.messages.DataModel` because it can accept any type of message. But in most cases, you should specify the\n    `InputType` and `OutputType` to be a specific subclass of `aact.messages.DataModel`.\n    \"\"\"\n\n    input_channel_types: dict[str, Type[InputType]]\n    \"\"\"\n    A dictionary that maps the input channel names to the corresponding input message types.\n    \"\"\"\n    output_channel_types: dict[str, Type[OutputType]]\n    \"\"\"\n    A dictionary that maps the output channel names to the corresponding output message types.\n    \"\"\"\n    redis_url: str\n    \"\"\"\n    The URL of the Redis server. It should be in the format of `redis://&lt;host&gt;:&lt;port&gt;/&lt;db&gt;`.\n    \"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n    \"\"\"\n    @private\n    \"\"\"\n\n    def __init__(\n        self,\n        input_channel_types: list[tuple[str, Type[InputType]]],\n        output_channel_types: list[tuple[str, Type[OutputType]]],\n        redis_url: str = \"redis://localhost:6379/0\",\n    ):\n        try:\n            super().__init__(\n                input_channel_types=dict(input_channel_types),\n                output_channel_types=dict(output_channel_types),\n                redis_url=redis_url,\n            )\n        except ValidationError as _:\n            raise NodeConfigurationError(\n                \"You passed an invalid configuration to the Node.\\n\"\n                f\"The required input channel types are: {self.model_fields['input_channel_types'].annotation}\\n\"\n                f\"The input channel types are: {input_channel_types}\\n\"\n                f\"The required output channel types are: {self.model_fields['output_channel_types'].annotation}\\n\"\n                f\"The output channel types are: {output_channel_types}\\n\"\n            )\n\n        self.r: Redis = Redis.from_url(redis_url)\n        \"\"\"\n        @private\n        \"\"\"\n        self.pubsub = self.r.pubsub()\n        \"\"\"\n        @private\n        \"\"\"\n        self.logger = logging.getLogger(\"aact.nodes.base.Node\")\n        \"\"\"\n        @private\n        \"\"\"\n\n    async def __aenter__(self) -&gt; Self:\n        try:\n            await self.r.ping()\n        except ConnectionError:\n            raise ValueError(\n                f\"Could not connect to Redis with the provided url. {self.redis_url}\"\n            )\n        await self.pubsub.subscribe(*self.input_channel_types.keys())\n        return self\n\n    async def __aexit__(self, _: Any, __: Any, ___: Any) -&gt; None:\n        await self.pubsub.unsubscribe()\n        await self.r.aclose()\n\n    async def _wait_for_input(\n        self,\n    ) -&gt; AsyncIterator[tuple[str, Message[InputType]]]:\n        async for message in self.pubsub.listen():\n            channel = message[\"channel\"].decode(\"utf-8\")\n            if message[\"type\"] == \"message\" and channel in self.input_channel_types:\n                try:\n                    data = Message[\n                        self.input_channel_types[channel]  # type: ignore[name-defined]\n                    ].model_validate_json(message[\"data\"])\n                except ValidationError as e:\n                    self.logger.error(\n                        f\"Failed to validate message from {channel}: {message['data']}. Error: {e}\"\n                    )\n                    raise e\n                yield channel, data\n        raise Exception(\"Input channel closed unexpectedly\")\n\n    async def event_loop(\n        self,\n    ) -&gt; None:\n        \"\"\"\n        The main event loop of the node.\n        The default implementation of the event loop is to wait for input messages from the input channels and call the\n        `event_handler` method for each input message, and send each output message to the corresponding output channel.\n        \"\"\"\n        try:\n            async for input_channel, input_message in self._wait_for_input():\n                async for output_channel, output_message in self.event_handler(\n                    input_channel, input_message\n                ):\n                    await self.r.publish(\n                        output_channel, output_message.model_dump_json()\n                    )\n        except NodeExitSignal as e:\n            self.logger.info(f\"Event loop cancelled: {e}. Exiting gracefully.\")\n        except Exception as e:\n            raise e\n\n    @abstractmethod\n    async def event_handler(\n        self, _: str, __: Message[InputType]\n    ) -&gt; AsyncIterator[tuple[str, Message[OutputType]]]:\n        \"\"\"\n        @private\n        \"\"\"\n        raise NotImplementedError(\"event_handler must be implemented in a subclass.\")\n        yield \"\", self.output_type()  # unreachable: dummy return value\n</code></pre>"},{"location":"api/nodes/#aact.Node.input_channel_types","title":"input_channel_types  <code>instance-attribute</code>","text":"<pre><code>input_channel_types: dict[str, Type[InputType]]\n</code></pre> <p>A dictionary that maps the input channel names to the corresponding input message types.</p>"},{"location":"api/nodes/#aact.Node.output_channel_types","title":"output_channel_types  <code>instance-attribute</code>","text":"<pre><code>output_channel_types: dict[str, Type[OutputType]]\n</code></pre> <p>A dictionary that maps the output channel names to the corresponding output message types.</p>"},{"location":"api/nodes/#aact.Node.redis_url","title":"redis_url  <code>instance-attribute</code>","text":"<pre><code>redis_url: str\n</code></pre> <p>The URL of the Redis server. It should be in the format of <code>redis://&lt;host&gt;:&lt;port&gt;/&lt;db&gt;</code>.</p>"},{"location":"api/nodes/#aact.Node.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre> <p>@private</p>"},{"location":"api/nodes/#aact.Node.r","title":"r  <code>instance-attribute</code>","text":"<pre><code>r: Redis = from_url(redis_url)\n</code></pre> <p>@private</p>"},{"location":"api/nodes/#aact.Node.pubsub","title":"pubsub  <code>instance-attribute</code>","text":"<pre><code>pubsub = pubsub()\n</code></pre> <p>@private</p>"},{"location":"api/nodes/#aact.Node.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = getLogger('aact.nodes.base.Node')\n</code></pre> <p>@private</p>"},{"location":"api/nodes/#aact.Node.event_loop","title":"event_loop  <code>async</code>","text":"<pre><code>event_loop() -&gt; None\n</code></pre> <p>The main event loop of the node. The default implementation of the event loop is to wait for input messages from the input channels and call the <code>event_handler</code> method for each input message, and send each output message to the corresponding output channel.</p> Source code in <code>src/aact/nodes/base.py</code> <pre><code>async def event_loop(\n    self,\n) -&gt; None:\n    \"\"\"\n    The main event loop of the node.\n    The default implementation of the event loop is to wait for input messages from the input channels and call the\n    `event_handler` method for each input message, and send each output message to the corresponding output channel.\n    \"\"\"\n    try:\n        async for input_channel, input_message in self._wait_for_input():\n            async for output_channel, output_message in self.event_handler(\n                input_channel, input_message\n            ):\n                await self.r.publish(\n                    output_channel, output_message.model_dump_json()\n                )\n    except NodeExitSignal as e:\n        self.logger.info(f\"Event loop cancelled: {e}. Exiting gracefully.\")\n    except Exception as e:\n        raise e\n</code></pre>"},{"location":"api/nodes/#aact.Node.event_handler","title":"event_handler  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>event_handler(_: str, __: Message[InputType]) -&gt; AsyncIterator[tuple[str, Message[OutputType]]]\n</code></pre> <p>@private</p> Source code in <code>src/aact/nodes/base.py</code> <pre><code>@abstractmethod\nasync def event_handler(\n    self, _: str, __: Message[InputType]\n) -&gt; AsyncIterator[tuple[str, Message[OutputType]]]:\n    \"\"\"\n    @private\n    \"\"\"\n    raise NotImplementedError(\"event_handler must be implemented in a subclass.\")\n    yield \"\", self.output_type()  # unreachable: dummy return value\n</code></pre>"},{"location":"api/nodes/#aact.NodeFactory","title":"aact.NodeFactory","text":"<p>To use nodes in the dataflow, you need to register them in the NodeFactory before using them. The reason for this is to allow users write string names in toml files which can be converted to actual classes at runtime.</p> <p>To register a node, you need to use the <code>@NodeFactory.register</code> decorator.</p> <p>Example:</p> <pre><code>from aact import Node, NodeFactory\n\n@NodeFactory.register(\"node_name\")\nclass YourNode(Node[your_input_type, your_output_type]):\n    # Your implementation of the node\n</code></pre>  For power users   You can initialize a node using the `NodeFactory.make` method.   <pre><code>from aact import NodeFactory\n\nnode = NodeFactory.make(\"node_name\", ...)# your arguments\n</code></pre>"},{"location":"api/nodes/#aact.NodeFactory.registry","title":"registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>registry: dict[str, type[Node[DataModel, DataModel]]] = {}\n</code></pre> <p>@private</p>"},{"location":"api/nodes/#aact.NodeFactory.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(name: str) -&gt; Callable[[type[Node[InputType, OutputType]]], type[Node[InputType, OutputType]]]\n</code></pre> <p>@private</p> Source code in <code>src/aact/nodes/registry.py</code> <pre><code>@classmethod\ndef register(\n    cls, name: str\n) -&gt; Callable[\n    [type[Node[InputType, OutputType]]], type[Node[InputType, OutputType]]\n]:\n    \"\"\"\n    @private\n    \"\"\"\n\n    def inner_wrapper(\n        wrapped_class: type[Node[InputType, OutputType]],\n    ) -&gt; type[Node[InputType, OutputType]]:\n        if name in cls.registry:\n            logger.warning(\"Executor %s already exists. Will replace it\", name)\n        cls.registry[name] = wrapped_class\n        return wrapped_class\n\n    return inner_wrapper\n</code></pre>"},{"location":"api/nodes/#aact.NodeFactory.make","title":"make  <code>classmethod</code>","text":"<pre><code>make(name: str, **kwargs: Any) -&gt; Node[DataModel, DataModel]\n</code></pre> <p>@private</p> Source code in <code>src/aact/nodes/registry.py</code> <pre><code>@classmethod\ndef make(cls, name: str, **kwargs: Any) -&gt; Node[DataModel, DataModel]:\n    \"\"\"\n    @private\n    \"\"\"\n    if name not in cls.registry:\n        raise ValueError(f\"Executor {name} not found in registry\")\n    return cls.registry[name](**kwargs)\n</code></pre>"}]}