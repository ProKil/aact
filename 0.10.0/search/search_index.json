{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[InputType, OutputType]</code></p> <p>Node is the base class for all nodes in the aact framework. It is a generic class that takes two type parameters: <code>InputType</code> and <code>OutputType</code>. The InputType and OutputType is used not only for static type checking but also for runtime message type validation, so it is important that you pass the correct types.</p> <p>Each of <code>InputType</code> and <code>OutputType</code> can be either: 1. a subclass of <code>aact.messages.DataModel</code>, or 2. a union of multiple <code>aact.DataModel</code> subclasses, or 3. <code>aact.DataModel</code> itself to allow any type of message (not recommended).[^1]</p> <p>Any subclass of <code>aact.Node</code> must implement the <code>event_handler</code> method, which is the main computation logic of the node. The <code>event_handler</code> method takes two arguments: <code>input_channel</code> and <code>input_message</code>, and returns an async iterator of tuples of output channel and output message.</p> <p>For example, the following code snippet shows a simple node that takes a <code>aact.messages.Text</code> message from the <code>a</code> channel and echo it to the <code>b</code> channel.</p> <pre><code>from aact import Node, Message\nfrom aact.messages import Text\n\nfrom typing import AsyncIterator\n\nclass EchoNode(Node[Text, Text]):\n    def event_handler(self, input_channel: str, input_message: Message[Text]) -&gt; AsyncIterator[str, Message[Text]]:\n        yield \"b\", Message[Text](data=input_message.data)\n</code></pre>"},{"location":"#aact.Node--built-in-nodes","title":"Built-in Nodes","text":"<p>aact provides several built-in nodes that you can use out of the box. Here are some of the built-in nodes:</p> <ul> <li><code>aact.nodes.listener.ListenerNode</code>: A node that listens to the audio input from the microphone.</li> <li><code>aact.nodes.speaker.SpeakerNode</code>: A node that plays the audio output to the speaker.</li> <li><code>aact.nodes.record.RecordNode</code>: A node that records the messages to a file.</li> <li><code>aact.nodes.print.PrintNode</code>: A node that prints the messages to the console.</li> <li><code>aact.nodes.tick.TickNode</code>: A node that sends a tick message at a fixed interval.</li> <li><code>aact.nodes.random.RandomNode</code>: A node that sends a random number message.</li> <li><code>aact.nodes.transcriber.TranscriberNode</code>: A node that transcribes the audio messages to text.</li> <li><code>aact.nodes.tts.TTSNode</code>: A node that converts the text messages to audio.</li> </ul>"},{"location":"#aact.Node--common-usage","title":"Common usage","text":"<p>The usage of nodes is in the quick start guide.</p>"},{"location":"#aact.Node--advanced-usage","title":"Advanced usage","text":""},{"location":"#aact.Node--send-messages-on-your-own","title":"Send messages on your own","text":"<p>The default behavior of sending messages in the base Node class is handled in the <code>event_loop</code> method. If you want to send messages on your own, you can directly use the Redis instance <code>r</code> to publish messages to the output channels.</p> <pre><code>\nclass YourNode(Node[InputType, OutputType]):\n\n    async def func_where_you_send_messages(self):\n        await self.r.publish(your_output_channel, Message[OutputType](data=your_output_message).model_dump_json())\n\n</code></pre>"},{"location":"#aact.Node--customize-set-up-and-tear-down","title":"Customize set up and tear down","text":"<p>You can customize the set up and tear down of the node by overriding the <code>__aenter__</code> and <code>__aexit__</code> methods. For example, you can open a file in the <code>__aenter__</code> method and close it in the <code>__aexit__</code> method.</p> <pre><code>\nclass YourNode(Node[InputType, OutputType]):\n\n    async def __aenter__(self) -&gt; Self:\n        self.file = open(\"your_file.txt\", \"w\")\n        return await super().__aenter__()\n\n    async def __aexit__(self, exc_type: Any, exc_value: Any, traceback: Any) -&gt; None:\n        self.file.close()\n        return await super().__aexit__(exc_type, exc_value, traceback)\n</code></pre> <p>This will ensure the file is closed properly even if an exception is raised.</p>"},{"location":"#aact.Node--background-tasks","title":"Background tasks","text":"<p>You can run background tasks in the node by creating a task in the <code>__aenter__</code> method and cancelling it in the <code>__aexit__</code> method.</p> <pre><code>\nclass YourNode(Node[InputType, OutputType]):\n\n    async def __aenter__(self) -&gt; Self:\n\n        self.task = asyncio.create_task(self.background_task())\n        return await super().__aenter__()\n\n    async def __aexit__(self, exc_type: Any, exc_value: Any, traceback: Any) -&gt; None:\n        self.task.cancel()\n\n        try:\n            await self.task\n        except asyncio.CancelledError:\n            pass\n</code></pre> <p>[^1]: Only if you know what you are doing. For example, in the <code>aact.nodes.record.RecordNode</code>, the <code>InputType</code> is <code>aact.messages.DataModel</code> because it can accept any type of message. But in most cases, you should specify the <code>InputType</code> and <code>OutputType</code> to be a specific subclass of <code>aact.messages.DataModel</code>.</p> Source code in <code>src/aact/nodes/base.py</code> <pre><code>def __init__(\n    self,\n    input_channel_types: list[tuple[str, Type[InputType]]],\n    output_channel_types: list[tuple[str, Type[OutputType]]],\n    redis_url: str = \"redis://localhost:6379/0\",\n):\n    try:\n        super().__init__(\n            input_channel_types=dict(input_channel_types),\n            output_channel_types=dict(output_channel_types),\n            redis_url=redis_url,\n        )\n    except ValidationError as _:\n        raise NodeConfigurationError(\n            \"You passed an invalid configuration to the Node.\\n\"\n            f\"The required input channel types are: {self.model_fields['input_channel_types'].annotation}\\n\"\n            f\"The input channel types are: {input_channel_types}\\n\"\n            f\"The required output channel types are: {self.model_fields['output_channel_types'].annotation}\\n\"\n            f\"The output channel types are: {output_channel_types}\\n\"\n        )\n\n    self.r: Redis = Redis.from_url(redis_url)\n    \"\"\"\n    @private\n    \"\"\"\n    self.pubsub = self.r.pubsub()\n    \"\"\"\n    @private\n    \"\"\"\n    self.logger = logging.getLogger(\"aact.nodes.base.Node\")\n    \"\"\"\n    @private\n    \"\"\"\n</code></pre>"},{"location":"#aact.Node.input_channel_types","title":"input_channel_types  <code>instance-attribute</code>","text":"<pre><code>input_channel_types: dict[str, Type[InputType]]\n</code></pre> <p>A dictionary that maps the input channel names to the corresponding input message types.</p>"},{"location":"#aact.Node.output_channel_types","title":"output_channel_types  <code>instance-attribute</code>","text":"<pre><code>output_channel_types: dict[str, Type[OutputType]]\n</code></pre> <p>A dictionary that maps the output channel names to the corresponding output message types.</p>"},{"location":"#aact.Node.redis_url","title":"redis_url  <code>instance-attribute</code>","text":"<pre><code>redis_url: str\n</code></pre> <p>The URL of the Redis server. It should be in the format of <code>redis://&lt;host&gt;:&lt;port&gt;/&lt;db&gt;</code>.</p>"},{"location":"#aact.Node.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre> <p>@private</p>"},{"location":"#aact.Node.r","title":"r  <code>instance-attribute</code>","text":"<pre><code>r: Redis = from_url(redis_url)\n</code></pre> <p>@private</p>"},{"location":"#aact.Node.pubsub","title":"pubsub  <code>instance-attribute</code>","text":"<pre><code>pubsub = pubsub()\n</code></pre> <p>@private</p>"},{"location":"#aact.Node.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = getLogger('aact.nodes.base.Node')\n</code></pre> <p>@private</p>"},{"location":"#aact.Node.event_loop","title":"event_loop  <code>async</code>","text":"<pre><code>event_loop() -&gt; None\n</code></pre> <p>The main event loop of the node. The default implementation of the event loop is to wait for input messages from the input channels and call the <code>event_handler</code> method for each input message, and send each output message to the corresponding output channel.</p> Source code in <code>src/aact/nodes/base.py</code> <pre><code>async def event_loop(\n    self,\n) -&gt; None:\n    \"\"\"\n    The main event loop of the node.\n    The default implementation of the event loop is to wait for input messages from the input channels and call the\n    `event_handler` method for each input message, and send each output message to the corresponding output channel.\n    \"\"\"\n    try:\n        async for input_channel, input_message in self._wait_for_input():\n            async for output_channel, output_message in self.event_handler(\n                input_channel, input_message\n            ):\n                await self.r.publish(\n                    output_channel, output_message.model_dump_json()\n                )\n    except NodeExitSignal as e:\n        self.logger.info(f\"Event loop cancelled: {e}. Exiting gracefully.\")\n    except Exception as e:\n        raise e\n</code></pre>"},{"location":"#aact.Node.event_handler","title":"event_handler  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>event_handler(_: str, __: Message[InputType]) -&gt; AsyncIterator[tuple[str, Message[OutputType]]]\n</code></pre> <p>@private</p> Source code in <code>src/aact/nodes/base.py</code> <pre><code>@abstractmethod\nasync def event_handler(\n    self, _: str, __: Message[InputType]\n) -&gt; AsyncIterator[tuple[str, Message[OutputType]]]:\n    \"\"\"\n    @private\n    \"\"\"\n    raise NotImplementedError(\"event_handler must be implemented in a subclass.\")\n    yield \"\", self.output_type()  # unreachable: dummy return value\n</code></pre>"}]}